package com.eloelo.analyticsimport android.app.Activityimport android.app.Applicationimport android.app.Application.ActivityLifecycleCallbacksimport android.os.Bundleimport android.util.Logimport androidx.lifecycle.LifecycleObserverimport androidx.work.Configurationimport androidx.work.DelegatingWorkerFactoryimport com.greenhorn.neuronet.EloAnalyticsSdkimport com.greenhorn.neuronet.constant.Constantimport com.greenhorn.neuronet.utils.EloAnalyticsConfigimport com.greenhorn.neuronet.utils.EloAnalyticsRuntimeProviderimport com.greenhorn.neuronet.utils.FlushPendingEventTriggerSourceimport com.greenhorn.neuronet.worker.syncWorker.EloAnalyticsWorkerFactoryimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.SupervisorJobimport kotlinx.coroutines.launchprivate const val TAG = "EloEloApplication"class EApplication : Application(), Configuration.Provider,    ActivityLifecycleCallbacks, LifecycleObserver {    private lateinit var delegatingWorkerFactory: DelegatingWorkerFactory    private var activityTag: String? = null    private var taskId: Int? = null    private val ioScope by lazy { CoroutineScope(Dispatchers.IO + SupervisorJob()) }    override fun onCreate() {        super.onCreate()        // Register activity lifecycle callbacks        registerActivityLifecycleCallbacks(this)        delegatingWorkerFactory = DelegatingWorkerFactory()        EloAnalyticsSdk.Builder(this)            .setRuntimeProvider(object : EloAnalyticsRuntimeProvider {                override suspend fun isUserLoggedIn(): Boolean {                    return true                }                override fun getAppVersionCode(): String {                    return "13133123"                }                override suspend fun getCurrentUserId(key: String): Long {                    return 10000                }                override suspend fun getGuestUserId(key: String): Long {                    return 111011L                }                override fun isAnalyticsSdkEnabled(): Boolean {                    return true                }            })            .setConfig(                config = EloAnalyticsConfig(                    batchSize = 2,                    baseUrl = "https://central-analytics-producer.eloelo.in/",                    endpointUrl = "v2/analytics/send/event/test",                    isDebug = true,                    headers = mapOf("version_code" to "1212",                        "father" to "23")                )            )            .build()        // Add analytics library's worker factory using dependency container from SDK        delegatingWorkerFactory.addFactory(            EloAnalyticsWorkerFactory()        )    }    override val workManagerConfiguration: Configuration        get() = Configuration.Builder()            .setMinimumLoggingLevel(Log.INFO)            .setWorkerFactory(delegatingWorkerFactory)            .build()    private fun flushPendingEloAnalyticsEvents(        flushPendingEventTriggerSource: FlushPendingEventTriggerSource,        activity: Activity    ) {        ioScope.launch {            EloAnalyticsSdk.getInstance().flushPendingEvents(                flushPendingEventTriggerSource,                activity = activity            )        }    }    override fun onActivityCreated(p0: Activity, p1: Bundle?) {}    override fun onActivityDestroyed(activity: Activity) {        flushPendingEloAnalyticsEvents(            flushPendingEventTriggerSource = FlushPendingEventTriggerSource.ACTIVITY_DESTROY,            activity = activity        )// flush events for activity destroyed case    }    override fun onActivityPaused(activity: Activity) {        Log.d(TAG, "onActivityPaused: ${activity::class.simpleName}")    }    override fun onActivityResumed(activity: Activity) {        Log.d(TAG, "onActivityResumed: ${activity::class.simpleName}")        taskId = activity.taskId        activityTag = activity.localClassName    }    override fun onActivitySaveInstanceState(activity: Activity, p1: Bundle) {}    override fun onActivityStarted(activity: Activity) {        Log.d(TAG, "onActivityStarted: ${activity::class.simpleName}")    }    override fun onActivityStopped(activity: Activity) {        Log.d(TAG, "onActivityStopped: $activity")        if (activity.localClassName == activityTag && activity.taskId == taskId) {            EloAnalyticsSdk.getInstance().trackEvent(                name = Constant.APP_MINIMISE_OR_EXITED,                eventData = mutableMapOf()            )            flushPendingEloAnalyticsEvents(                flushPendingEventTriggerSource = FlushPendingEventTriggerSource.APP_MINIMIZE,                activity = activity            ) // flush events for app minimise case        }    }}